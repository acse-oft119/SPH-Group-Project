#+TITLE: Documentation

#+OPTIONS: toc:nil

This tool has been implemented in C++ with Python as a means to analyze data and
test the output of the code. Bellow is the documentation of the functions used
in the tool and an analysis of the testing pipline.

* Code structure, Class variables and functions
The tool is composed of two classes /SPH_particle/ and /SPH_main/.
/SPH_particle/ is an object that represents each individual particle in our
simulation and holds parameters and values that are specific to every particle
(eg. position, velocity, etc). /SPH_main/ represents the domain the simulation
is using and holds all the functions, globals and data strucutres needed to run
the simulation.

#+TOC: headlines 2
** /SPH_particle/
**** TODO Include complete descriptions of class variables

*** Class variables:
- x[] (double) :: Position
- v[] (double) :: Velocity
- rho (double) :: Density
- P (double) :: Pressure
- a[] (double) :: Acceleration
- D (double) :: Rate of change of density
- rho2 (dobule) ::
- vij_half[] (double) ::
- x_half[] (double) :: Position
- v_half[] (double) :: Velocity
- rho_half (double) :: Density
- a_half[] (double) :: Acceleration
- D_half (double) :: Rate of change of density
- numerator (double) ::
- denominator (double) ::
- main_data (staic SPH_main *) :: Link to SPH_main class so that it can be used
  to calc_index
- list_num[] (int) :: Index in neighbour finding array
- is_boundary (bool) :: Set true if the particle is part of the boundary

*** Class functions:
- calc_index(/void/) (void) ::
** /SPH_main/

**** TODO Include complete descriptions of class variables and functions
*** Class variables:
- h (double) :: Smoothing length
- h_fac (double) ::
- dx (double) :: Particles initial spacing
- c0 (double) :: Speed of sound
- dt (double) :: Timestep
- g[] (double) :: Gravity constant
- mu (double) :: Viscocity
- rho0 (double) :: Initial density
- B (double) ::
- gamma (double) ::
- mass (double) ::

For dynamic time stepping

- v_max (double) ::
- a_max (double) ::
- rho_max (double) ::
- dt_cfl (double) ::
- dt_f (double) ::
- dt_a (double) ::
- cfl (double) ::

- min_x[], max_x[] (double) :: Dimensions of simulation region
- grid_count (vector<vector<int>>) ::
- max_list[] (int) ::
- particle_list (vector<SPH_particle>) :: List of all the particles
- search_grid (<vector<vector<vector<SPH_particle*>>>) :: Outer two vectors are
  the grid, inner vector is the list.

*** Class functions:
- SPH_main() :: Main constructor.
- cubic_spline(/double r[]/) (double) ::
- cubic_spline_first_derivative(/double r[]/) (double) ::
- update_gradients(/double r[]/, /SPH_particle* part/, /SPH_particle* other_part/) (void) ::
- density_field_smoothing(/SPH_particle* part/) (void) ::
- set_values(/double delta_x/) (void) :: Setting simulation parameters.
- initialize_grid(/void/) (void) ::
- place_points(/double min0/, /double min1/, /double max0/, /double max1/, /bool type/) (void) ::
- allocate_to_grid(/void/) (void) :: Allocates all the points to the search grid
  (assumes that index has been appropriately update).
- neighbour_iterate(/SPH_particle* part/) (void) ::
- update_particle(/SPH_particle* part/) (void) ::
- reset_grid_count() (void) ::
- update_rho(/SPH_particle* part/) (void) ::
- store_initial(/SPH_particle* part/) (void) ::
- time_dynamic() (void) ::
- full_update(/SPH_particle* part/) (void) ::
- get_new_max(/SPH_particle* part/) (void) ::

* Running the Simulation, Post-processing and Output scripts
A sample C++ file (/SPH_Snippet.cpp/) has been provided in the package that runs
the simulation for the parameters required for the class excericse. That file is
responsible for the entirety of the simulation and serves as a template for any
future simulations anyone would want to run using this tool. Moreover, a
number of post processing scripts have been implemented in C++ and Python for
the purpose of outputing the simulation states in a suitable format for both
visualization and data manipulation.

** file_writer.cpp
A simple C++ file that outputs simulation steps as /.vtp/ files; to be used with
ParaView or other software that is build upon the /VTK/ library.
** post.py
A simple Python script that takes the /.vtp/ files created by /file_writer.cpp/,
creates a Pandas DataFrame for every iteration step and outputs them in a HDF5
file (for easy data transport and data manipulation). A similar version of the
script is used in the testing pipeline in the step where the testing moves from
C++ to Python.

* Testing
Testing on this tool is done by both C++ and Python. For C++ the BOOST library
is used and for Python a custom test file has been written.

** C++ Testing
The C++ side of the testing handles all the mathematical functions defined in
the /SPH_main/ class. Namely /cubic_spline/, /cubic_spline_first_derivative/ and
/update_gradients/. A set of BOOST test cases has been set that depends on the
possible outputs of the spline functions. Note, that the same principle is
applied for /update_gradients/ as the cubic spline functions play an important
role in the calculation of acceleration and rate of change of pressure.
Moreover, the tests are conducted independently of the model parameters (as they
are defined in the /set_vales/ functions), by setting the desired parameters
before the function call.
** Python Testing
The Python part of the testing deals with validating the behaviour of the
simulator; checking that the particles stay within the boundaries and that the
particles are present at their proper positions after /N/ iterations steps. This
part of the testing can be used for validating that the input parameters by the
user fall within the power of the simulator (ie that the simulator does not
become unstable).
** Testing pipeline
The teting pipeline goes as follows:
1. The objects and C++ classes get compiled.
2. The Python script /run_tests.py/ is being run, which is responsible for
   running both the C++ and Python tests.
3. The C++ test file /test_SPH_2D.cpp/ is run, followed by
   /test_file_writer.cpp/ which outputs a set of /.vtp/ files, containing the
   iteration steps of the test simulator.
4. /test_post.py/ is called (a specialised version of /post.py/) which processes
   the /.vtp/ files and creates the /output_test.h5/ file, containing all the
   Pandas DataFrames to be used by the Python part of the tests.
5. /python_tests.py/ is run with /output_test.h5/ as input; completing a number
   of tests on the behaviour of the simulator.

*Note: The following commands are to be entered from the base repository of the package.*
The complete testing pipeline can be run by using:
#+BEGIN_SRC bash
make runtests
#+END_SRC

To run only the C++ tests you can use:
#+BEGIN_SRC bash
./tests/bin/test_SPH_2D
#+END_SRC
The /--log_level=unit_scope/ flag can be used to give a detailed report of the
testing suite and /--list_content/ provides the user for a description of each
testing case for easier debugging.

To produce the /.vtp/ files you can use:
#+BEGIN_SRC bash
./tests/bin/test_file_writer
#+END_SRC

To produce the /.h5/ test files you can use:
#+BEGIN_SRC bash
python ./tests/test_post.py
#+END_SRC
(It goes without saying that the /.vtp/ files need to already exist for the
/.h5/ files to be produced.)
